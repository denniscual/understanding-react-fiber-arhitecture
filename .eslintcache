[{"/Users/admin/Desktop/projects/tests/scheduling-demo/src/App.tsx":"1","/Users/admin/Desktop/projects/tests/scheduling-demo/src/reportWebVitals.ts":"2","/Users/admin/Desktop/projects/tests/scheduling-demo/src/index.tsx":"3","/Users/admin/Desktop/projects/tests/scheduling-demo/src/ThisIsATest.tsx":"4"},{"size":2957,"mtime":1627040992679,"results":"5","hashOfConfig":"6"},{"size":425,"mtime":1606978460845,"results":"7","hashOfConfig":"6"},{"size":245,"mtime":1626942508855,"results":"8","hashOfConfig":"6"},{"size":16184,"mtime":1627289253637,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"9zvd1c",{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"16","messages":"17","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"18"},"/Users/admin/Desktop/projects/tests/scheduling-demo/src/App.tsx",["19","20","21","22"],"/Users/admin/Desktop/projects/tests/scheduling-demo/src/reportWebVitals.ts",[],"/Users/admin/Desktop/projects/tests/scheduling-demo/src/index.tsx",[],"/Users/admin/Desktop/projects/tests/scheduling-demo/src/ThisIsATest.tsx",["23","24"],"export default function ThisIsATest() {\n  return (\n    <div>\n      <span>Hello world</span>\n    </div>\n  )\n}\n\n// TODO:\n// - Review this begin work.\n// - Do the completeUnitOfWork and completeWork.\n// - Do the commit phase.\n\n// Fiber architecture.\n// So basically it starts in the creation of the fiber root object which is based on the \"passed\" container\n// in ReactDOM. This root object handles the \"Fiber\" tree. Then it creates a root fiber node where the state\n// node is pointing back to the fiber root object.\n//\n// There are 2 phases.\n// - Render phase\n// - Commit phase\n//\n// In the begin work, it updates the element. But im thinking this updates are wrapped to a update function\n// which will run in the \"commit phase\".\n//\n// And then in the complete work work, this is the place where React append the DOM nodes. First it creates the DOM node for every child. Then creates the parent and append the children to this parent DOM node based on the `workInProgress` children.\n// It uses the same traversal for appending children dom nodes to the parent. Its the \"Singly linked-list\" traversal.\n//\n// In commit phase, especially commitMutationEffects, the appending of the App DOM tree is happening in here.\n// So React will append the App DOM tree to the root container which \"schedules\" a \"yield\".\n\n// First create fiber root object and create fiber node on top of this.\n// Then this fiber node will be `current` of the fiber root ojbect.\n// Then create a work in progress node based on current. Just copy the `current` but we need to make sure\n// these 2 fiber nodes are referential different. When creating a current/work in progress for host root,\n// the fiber node has `updateQueue` which holds the app root react element (E.g the app).\n// Simple representation of the work in progress node of the host root.\n// It has `updateQueue` which holds the Root react element (App) on its baseState field.\n// Then create a fiber node based on the App react element. Set the `return` field to the host root.\n// And for host root, set its child field to the APp fiber node. Then this `child` is the returned fiber node\n// of the beginWork for the hostRoot.\n// Then continue the same algorithm for App and so on and so forth.\n//\n//\n// In completeWork, this is the function in render phase where React appends the children to its parent if the\n// the workInProgress fiber node is a HOST_COMPONENT. Check createInstance function. If not, then completeWork immediately returns null. Basically what i know is that\n// in completeWork, React also add the effectTag of the fiber node based on the changes.\n//\n// NOTE: For function component, we don't need to assign a stateNode.\n\ntype TElementType = any\ninterface TElement {\n  type: TElementType\n  props: any\n  key: any\n}\ninterface TReactComponent {\n  (...args: any[]): JSX.Element\n}\n\nenum TFiberNodeTags {\n  NONE = 0,\n  HOST_ROOT = 1,\n  HOST_COMPONENT = 2,\n  FUNCTION_COMPONENT = 3,\n}\n\nclass FiberNode {\n  type: TElementType\n  tag: TFiberNodeTags = 0\n  return: MaybeFiberNode = null\n  child: MaybeFiberNode = null\n  sibling: MaybeFiberNode = null\n  updateQueue: {} | null = null\n  stateNode: any = null\n  alternate: MaybeFiberNode = null\n  pendingProps: any = null\n  memoizedProps: any = null\n  memoizedState: any\n  key: any = undefined\n\n  constructor(type: TElementType, props: any, key: any) {\n    this.type = type\n    this.pendingProps = props\n    this.key = key\n  }\n}\n\ntype MaybeFiberNode = FiberNode | null\n\nclass FiberRootObject {\n  finishedWork: MaybeFiberNode = null\n  current: MaybeFiberNode = null\n}\n\nlet fiberRootObject: FiberRootObject | null = null\n\nfunction workLoopSync(unitOfWork: FiberNode) {\n  let workInProgress: MaybeFiberNode = unitOfWork\n  while (workInProgress !== null) {\n    // Start of the \"render phase\".\n    workInProgress = performUnitOfWork(workInProgress)\n  }\n\n  // Start of the \"commit phase\".\n}\n\nfunction performUnitOfWork(unitOfWork: FiberNode): MaybeFiberNode {\n  const current = unitOfWork.alternate\n  let nextUnitOfWork: MaybeFiberNode = beginWork(current, unitOfWork)\n\n  // Assign the new props of the unitOfWork to its memoizedProps if all `beginWork` works are done.\n  // This new props will be the props of the fiber node to the next current state of the app.\n  unitOfWork.memoizedProps = unitOfWork.pendingProps\n\n  if (nextUnitOfWork === null) {\n    // Call the completeUnitOfWork\n  }\n\n  return nextUnitOfWork\n}\n\nfunction beginWork(current: MaybeFiberNode, workInProgress: FiberNode) {\n  //if (current !== null) {\n  //  // This `workInProgress` is already included in the current state of the App.\n  //  // So basically this is an \"Update/Re-render\".\n  //  //\n  //  // Basically, when React creates the `workInProgress` and before React goes to this `beginWork` function,\n  //  // the `workInProgress` pendingProps is already updated.\n  //  //\n  //  // E.g\n  //  // App has Text component which is relying to the `count` state of the App. App passed it via `props`.\n  //  // And App schedules an `update` to this `count` state. Expected behaviour is that App will pass\n  //  // the updated `count` state to the `Text`.\n  //  //\n  //  // So in the `beginWork`, React will compute the new state of the `count` before it creates the new child of the App\n  //  // based on the `workInProgress.child.alternate` and also the new state. This new updated child of the App will\n  //  // have the `pendingProps` and will point to the new state.\n  //  // Then beginWork returns the new updated child of the App and will be assigned as the new `nextUnitOfWork`.\n  //  // So it means that if the `workInProgress` is the updated child of the App, then the `workInProgress.pendingProps`\n  //  // is already updated. It is updated in the time App was passed in this function.\n  //  // Basically the `props` is computed via invoking the Component's render method or calling the function component.\n  //  // @ts-ignore\n  //  const oldProps = current.memoizedProps\n  //  const newProps = workInProgress.pendingProps\n\n  //  if (oldProps !== newProps) {\n  //    // Do diff in here. I think so!\n  //  }\n  //}\n\n  const { tag } = workInProgress\n\n  switch (tag) {\n    case TFiberNodeTags.HOST_ROOT: {\n      if (!current)\n        throw new Error(\n          'If the current host root fiber node is \"null\", then this is likely bug in React.'\n        )\n\n      // Map the Root react element, e.g the App, to fiber node and return it.\n      return updateHostRoot(current, workInProgress)\n    }\n\n    // Basically, if there is state chagnes in the component and this state is passed to its child component. then it means that before React creates/clone the fiber of the child component of the workInProgress fiber node, it needs to compute\n    // first its \"state\" then pass the \"new\" props to the cloned fiber node via its `fiberNode.pendingProps`.\n    // With this, whenever that cloned fiber node is the `workInProgress` handle by `beginWork`, the next props (pendingProps) is already computed. And React will diff this node via its `workInProgress.memoizedProps` and `workInProgress.pendingProps`.\n\n    case TFiberNodeTags.HOST_COMPONENT: {\n      // Map its react children to fiber nodes and return its first child\n      // The generated fiber nodes are based on the React children. Means it will copy the information from the react elements to create fiber nods like \"props\".\n      // So the meaning of \"reconcile\" in here is to create or clone a fiber nodes based on the React elements and if there is - to its current fiber nodes (workInProgress.alternate).\n      // And these changes are determined by its state and props.\n      return updateHostComponent(current, workInProgress)\n    }\n    default: {\n      // Map its react children to fiber nodes and return its first child\n      // The generated fiber nodes are based on the React children. Means it will copy the information from the react elements to create fiber nods like \"props\".\n      // So the meaning of \"reconcile\" in here is to create or clone a fiber nodes based on the React elements and if there is - to its current fiber nodes (workInProgress.alternate).\n      // And these changes are determined by its state and props.\n      return mountIndeterminateComponent(\n        current,\n        workInProgress,\n        workInProgress.type\n      )\n    }\n  }\n}\n\n// It is named \"updateHostRoot\" because this function updates its fiber node via the `workInProgress`. All changes must\n// be written in `workInProgress` btw because its the draft state. Sample of the \"updates\" are setting its child fiber node and add \"effect\" tag.\nfunction updateHostRoot(current: FiberNode, workInProgress: FiberNode) {\n  workInProgress.memoizedState = {\n    // @ts-ignore\n    element: workInProgress.updateQueue.baseState,\n  }\n  const nextState = workInProgress.memoizedState\n  const nextChildren = nextState.element\n  reconcileChildren(current, workInProgress, nextChildren)\n  return workInProgress.child\n}\n\n// It is named \"updateHostComponent\" because this function updates its fiber node via the `workInProgress`. All changes must\n// be written in `workInProgress` btw because its the draft state. Sample of the \"updates\" are setting its child fiber node and add \"effect\" tag.\nfunction updateHostComponent(\n  current: MaybeFiberNode,\n  workInProgress: FiberNode\n) {\n  const nextProps = workInProgress.pendingProps\n  let nextChildren = nextProps.children\n  const isDirectTextChild = shouldSetTextContent(workInProgress.type, nextProps)\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also has access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null\n  }\n  reconcileChildren(current, workInProgress, nextChildren)\n  return workInProgress.child\n}\n\nfunction shouldSetTextContent(type: any, props: any) {\n  return typeof props.children === 'string'\n}\n\nfunction mountIndeterminateComponent(\n  current: MaybeFiberNode,\n  workInProgress: FiberNode,\n  Component: TReactComponent\n) {\n  const children = Component(workInProgress.pendingProps)\n  reconcileChildren(null, workInProgress, children)\n  return workInProgress.child\n}\n\nfunction reconcileChildren(\n  current: MaybeFiberNode,\n  workInProgress: FiberNode,\n  nextChildren: TElement\n) {\n  // In the react-reconciler, there 2 different child reconcilers, the same logic but one will track if there side-effects, which are ran in here. One is reconciler for update\n  // which \"tracks\" side-effects. E.g if there are scheduled mutation to the host component.\n  // Another child reconciler will not track the side-effects. This will happen if the `workInProgress` is a fresh fiber node. Meaning that it is not yet rendered on the screen.\n  // If this is a fresh new component that hasn't been rendered yet.\n  // if (current === null) {\n  //   workInProgress.child = mountChildFibers(workInProgress, null, nextChildren)\n  // } else {\n  //   workInProgress.child = reconcileChildFibers(\n  //     workInProgress,\n  //     current.child,\n  //     nextChildren\n  //   )\n  // }\n\n  // In our mock, we will just run the `mountChildFibers` for now because our codes will not support the \"updates\".\n  workInProgress.child = mountChildFibers(workInProgress, null, nextChildren)\n}\n\n// This function and `reconcileChildren` are kinda the same. These functions are used for creating/cloning fiber node.\n// One of the difference is that `reconcileChildren` tracks side effects.\nfunction mountChildFibers(\n  returnFiber: FiberNode,\n  currentFirstChild: MaybeFiberNode,\n  newChild: TElement\n) {\n  // If it is a React element.\n  if (typeof newChild === 'object' && newChild !== null) {\n    return reconcileSingleElement(returnFiber, currentFirstChild, newChild)\n  } else if (Array.isArray(newChild)) {\n    return null\n    // return reconcileChildrenArray(returnFiber, currentFirstChild, newChild)\n  } else {\n    // newChild is a direct text child of a Host node. For this text child, we don't need to create a fier node.\n    return null\n  }\n}\n\n// This function and `mountChildFibers` are kinda the same. These functions are used for creating/cloning fiber node.\n// One of the difference is that `reconcileChildren` tracks side effects.\n// function reconcileChildFibers(\n//   returnFiber: FiberNode,\n//   currentFirstChild: MaybeFiberNode,\n//   newChild: TElement\n// ) {\n//   // If it is a React element.\n//   if (typeof newChild === 'object' && newChild !== null) {\n//     return reconcileSingleElement(returnFiber, currentFirstChild, newChild)\n//   } else if (Array.isArray(newChild)) {\n//     return null\n//     // return reconcileChildrenArray(returnFiber, currentFirstChild, newChild)\n//   } else {\n//     // newChild is a direct text child of a Host node. For this text child, we don't need to create a fier node.\n//     return null\n//   }\n// }\n\n// Reconcile means creating or cloning a fiber node based on the React element.\nfunction reconcileSingleElement(\n  returnFiber: FiberNode,\n  currentFirstChild: MaybeFiberNode,\n  element: TElement\n) {\n  const child = currentFirstChild\n  const createdFiberNode = createFiberFromElement(element)\n  createdFiberNode.return = returnFiber\n  createdFiberNode.child = child\n  return createdFiberNode\n}\n\nfunction createFiberFromElement(element: TElement) {\n  const type = element.type\n  const key = element.key\n  const pendingProps = element.props\n  const fiber = createFiber(type, pendingProps, key)\n  return fiber\n}\n\nfunction createHostRootFiber(root: FiberRootObject, element: TElement) {\n  const current = createFiber(root)\n  current.updateQueue = {\n    baseState: element,\n  }\n  current.stateNode = root\n  // Point the alternate to `workInProgress`.\n  current.alternate = createFiber(root)\n\n  // Copy some information from the `current`.\n  const workInProgress = current.alternate\n  workInProgress.updateQueue = current.updateQueue\n  workInProgress.stateNode = current.stateNode\n  // Point the alternate to `current`.\n  workInProgress.alternate = current\n  return current\n}\n\nfunction createFiber(type: TElementType, props: any = null, key?: any) {\n  const fiberNode = new FiberNode(type, props, key)\n\n  if (type instanceof FiberRootObject) {\n    fiberNode.tag = TFiberNodeTags.HOST_ROOT\n  } else if (typeof type === 'string') {\n    fiberNode.tag = TFiberNodeTags.HOST_COMPONENT\n  } else if (typeof type === 'function') {\n    fiberNode.tag = TFiberNodeTags.FUNCTION_COMPONENT\n  } else {\n    fiberNode.tag = TFiberNodeTags.NONE\n  }\n  return fiberNode\n}\n\nfunction completeUnitOfWork() {\n  // returns or assign the nextUnitOfWork via `sibling`. If the `completedWork` doesnt have `child`, then set\n  // the completeWork and workInProgress to the returnFiber/parent of the `completeWork`.\n}\n\nfunction completeWork() {\n  // Do a switch for the workInProgress.tag\n  // If tag is HOST_COMPONENT, then create dom element with the pendingProps. And because the children of\n  // the workInProgress is already been created, children is created first before its parent, then\n  // we can append the direct children of the dom element. Don't need to include the inclusive descendants of the parent element\n  // because those are already appended to the children dom elements.\n}\n\nrender(jsx(App), document.createElement('div'))\n\nfunction render(element: TElement, container: HTMLElement) {\n  const root = new FiberRootObject()\n  root.current = createHostRootFiber(root, element)\n  fiberRootObject = root\n\n  const workInProgress = fiberRootObject.current?.alternate\n  // Invoking `workLoopSync` will start the \"render\" phase.\n  workLoopSync(workInProgress as FiberNode)\n\n  // After \"render\" phase, React will start the \"commit\" phase.\n}\n\nfunction App() {\n  return jsx(Test)\n}\n\nfunction Test() {\n  return jsx(\n    'div',\n    {},\n    jsx(\n      'span',\n      {\n        color: 'yellow',\n      },\n      'Hello world'\n    )\n  )\n}\n\nfunction jsx(type: any, props: any = {}, children: any = null): TElement {\n  let elementProps: any = {}\n  elementProps = {\n    ...props,\n  }\n  if (children) {\n    elementProps.children = children\n  }\n  return {\n    type,\n    props: elementProps,\n    key: props.key,\n  }\n}\n",{"ruleId":"25","severity":1,"message":"26","line":56,"column":7,"nodeType":"27","messageId":"28","endLine":56,"endColumn":22},{"ruleId":"25","severity":1,"message":"29","line":61,"column":10,"nodeType":"27","messageId":"28","endLine":61,"endColumn":16},{"ruleId":"25","severity":1,"message":"30","line":62,"column":9,"nodeType":"27","messageId":"28","endLine":62,"endColumn":17},{"ruleId":"25","severity":1,"message":"31","line":113,"column":11,"nodeType":"27","messageId":"28","endLine":113,"endColumn":21},{"ruleId":"25","severity":1,"message":"32","line":352,"column":10,"nodeType":"27","messageId":"28","endLine":352,"endColumn":28},{"ruleId":"25","severity":1,"message":"33","line":357,"column":10,"nodeType":"27","messageId":"28","endLine":357,"endColumn":22},"@typescript-eslint/no-unused-vars","'counterElements' is assigned a value but never used.","Identifier","unusedVar","'render' is defined but never used.","'hostRoot' is assigned a value but never used.","'TComponent' is defined but never used.","'completeUnitOfWork' is defined but never used.","'completeWork' is defined but never used."]